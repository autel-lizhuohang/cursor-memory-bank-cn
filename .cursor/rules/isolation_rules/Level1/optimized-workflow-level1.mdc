---
description: 优化的一级工作流程，用于快速修复Bug，注重Token效率
globs: "**/level1*/**", "**/quick*/**", "**/bugfix*/**"
alwaysApply: false
---

# 优化的一级工作流程

> **简述：** 这是一个针对一级任务（快速Bug修复）的精简工作流程，在保持质量的同时优化速度和Token效率。

## 🔧 一级流程图

```mermaid
graph TD
    Start["开始一级<br>快速修复"] --> Analyze["1️⃣ 分析<br>理解问题"]
    Analyze --> Build["2️⃣ 构建<br>修复问题"]
    Build --> Verify["3️⃣ 验证<br>测试修复"]
    Verify --> Document["4️⃣ 文档<br>记录方案"]

    style Start fill:#4da6ff,stroke:#0066cc,color:white
    style Analyze fill:#ffa64d,stroke:#cc7a30,color:white
    style Build fill:#4dbb5f,stroke:#36873f,color:white
    style Verify fill:#d94dbb,stroke:#a3378a,color:white
    style Document fill:#4dbbbb,stroke:#368787,color:white
```

## 📝 整合式文档

一级任务使用单文件方式以减少上下文切换：

```markdown
# 快速修复: [问题名称]

## 问题摘要
- 类型: [Bug/紧急修复/快速增强]
- 优先级: [低/中/高/紧急]
- 报告人: [姓名/系统]
- 影响范围: [组件/功能]

## 分析
- 根本原因: [简要描述]
- 受影响文件: [文件列表]
- 影响: [影响范围]

## 解决方案
- 方法: [简要描述]
- 所做更改: [更改列表]
- 执行的命令: [关键命令]

## 验证
- 测试: [修复如何测试]
- 结果: [测试结果]
- 额外检查: [其他验证]

## 状态
- [x] 修复已实现
- [x] 测试已通过
- [x] 文档已更新
```

## 🔄 memory bank更新

一级任务使用简化的memory bank更新，开销最小：

```markdown
## tasks.md 更新 (一级)

### 任务: [任务名称]
- 状态: 已完成
- 实现: [一行摘要]
- 修复链接: [文件/行引用]
```

## ⚡ Token优化模板

为了最大效率，一级任务可以使用这个超紧凑模板：

```markdown
## 🔧 修复: [问题]
📌 问题: [简要描述]
🔍 原因: [根本原因]
🛠️ 方案: [实现的修复]
✅ 测试: [验证方法]
```

## 🔄 自动文档助手

使用这些助手自动生成文档：

```javascript
function generateLevel1Documentation(issue, rootCause, solution, verification) {
  return `## 🔧 修复: ${issue}
📌 问题: ${issue}
🔍 原因: ${rootCause}
🛠️ 方案: ${solution}
✅ 测试: ${verification}`;
}
```

## 📊 常见问题快速模板

### 性能修复
```markdown
## 🔧 修复: [组件]中的性能问题
📌 问题: [组件]响应时间慢
🔍 原因: 查询/算法效率低下
🛠️ 方案: 优化了[具体优化内容]
✅ 测试: 响应时间从[X]ms改善到[Y]ms
```

### Bug修复
```markdown
## 🔧 修复: [组件]中的Bug
📌 问题: [特定行为]无法正常工作
🔍 原因: [根本原因分析]
🛠️ 方案: 通过[实现细节]修复
✅ 测试: 使用[测试方法]验证
```

### 快速增强
```markdown
## 🔧 增强: [功能]
📌 需求: 添加[具体功能]
🛠️ 实现: 通过[实现细节]添加
✅ 测试: 使用[测试方法]验证
```

## ✅ 精简验证

一级任务使用最小化验证流程：

```markdown
验证:
[x] 修复已实现并测试
[x] 未引入回归
[x] 文档已更新
```

## 🚀 整合式memory bank更新

通过单次操作优化一级任务的memory bank更新：

```javascript
// 优化一级memory bank更新的伪代码
function updateLevel1MemoryBank(taskInfo) {
  // 读取当前 tasks.md
  const tasksContent = readFile("tasks.md");

  // 创建最小更新
  const updateBlock = `
### 任务: ${taskInfo.name}
- 状态: 已完成
- 实现: ${taskInfo.solution}
- 修复链接: ${taskInfo.fileReference}
`;

  // 将更新添加到 tasks.md
  const updatedContent = appendToSection(tasksContent, "已完成任务", updateBlock);

  // 单次写入操作
  writeFile("tasks.md", updatedContent);

  return "memory bank已更新";
}
```

## 🔄 优化的一级工作流程示例

```markdown
## 🔧 修复: 移动设备上登录按钮无法工作

📌 问题:
用户无法在移动设备上登录，按钮显示但不触发认证

🔍 原因:
事件监听器使用了桌面特定事件（mousedown 而不是处理触摸事件）

🛠️ 方案:
更新事件处理以使用事件委托并支持鼠标和触摸事件：
```js
// 修改前:
loginButton.addEventListener('mousedown', handleLogin);

// 修改后:
loginButton.addEventListener('mousedown', handleLogin);
loginButton.addEventListener('touchstart', handleLogin);
```

✅ 测试:
- 在 iOS Safari 和 Android Chrome 上验证
- 登录现在在所有测试的移动设备上正常工作
- 桌面浏览器无回归
```

## ⚡ Token效率优势

这个优化的一级工作流程提供：

1. 减少文档开销（减少70%）
2. 整合memory bank更新（单次操作 vs 多次操作）
3. 聚焦验证流程（仅必要检查）
4. 基于模板的常见场景处理方法
5. 精简的工作流程，步骤更少

更新后的方法在显著减少Token使用的同时保留所有关键信息。
